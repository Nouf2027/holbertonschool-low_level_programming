#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <elf.h>
#define DIE(msg, code) do { dprintf(STDERR_FILENO, "%s\n", (msg)); exit(code); } while (0)
static unsigned short bswap16(unsigned short x){return (x>>8)|(x<<8);}
static unsigned int bswap32(unsigned int x){return((x&0x000000FFU)<<24)|((x&0x0000FF00U)<<8)|((x&0x00FF0000U)>>8)|((x&0xFF000000U)>>24);}
static unsigned long bswap64(unsigned long x){return((x&0x00000000000000FFULL)<<56)|((x&0x000000000000FF00ULL)<<40)|((x&0x0000000000FF0000ULL)<<24)|((x&0x00000000FF000000ULL)<<8)|((x&0x000000FF00000000ULL)>>8)|((x&0x0000FF0000000000ULL)>>24)|((x&0x00FF000000000000ULL)>>40)|((x&0xFF00000000000000ULL)>>56);}
static void print_magic(unsigned char *e_ident){size_t i;printf("ELF Header:\n");printf("  Magic:   ");for(i=0;i<EI_NIDENT;i++)printf("%02x%s",e_ident[i],i+1==EI_NIDENT?"":" ");printf("\n");}
static const char *class_str(unsigned char c){if(c==ELFCLASS32)return"ELF32";if(c==ELFCLASS64)return"ELF64";return"none";}
static const char *data_str(unsigned char d){if(d==ELFDATA2LSB)return"2's complement, little endian";if(d==ELFDATA2MSB)return"2's complement, big endian";return"none";}
static const char *osabi_str(unsigned char o){switch(o){case ELFOSABI_SYSV:return"UNIX - System V";case ELFOSABI_HPUX:return"HP-UX";case ELFOSABI_NETBSD:return"NetBSD";case ELFOSABI_LINUX:return"UNIX - Linux";case ELFOSABI_SOLARIS:return"Solaris";case ELFOSABI_IRIX:return"IRIX";case ELFOSABI_FREEBSD:return"FreeBSD";case ELFOSABI_TRU64:return"TRU64 UNIX";case ELFOSABI_ARM:return"ARM";case ELFOSABI_STANDALONE:return"Standalone App";default:return"<unknown: %u>";}}
static const char *type_str(unsigned int t){switch(t){case ET_NONE:return"NONE (None)";case ET_REL:return"REL (Relocatable file)";case ET_EXEC:return"EXEC (Executable file)";case ET_DYN:return"DYN (Shared object file)";case ET_CORE:return"CORE (Core file)";default:return"<unknown>";}}
int main(int argc,char **argv){int fd,r;unsigned char e_ident[EI_NIDENT];if(argc!=2)DIE("Usage: elf_header elf_filename",98);fd=open(argv[1],O_RDONLY);if(fd==-1)DIE("Error: Can't read file",98);r=read(fd,e_ident,EI_NIDENT);if(r!=(int)EI_NIDENT){close(fd);DIE("Error: Can't read ELF header",98);}if(!(e_ident[EI_MAG0]==ELFMAG0&&e_ident[EI_MAG1]==ELFMAG1&&e_ident[EI_MAG2]==ELFMAG2&&e_ident[EI_MAG3]==ELFMAG3)){close(fd);DIE("Error: Not an ELF file - it has the wrong magic bytes",98);}print_magic(e_ident);if(e_ident[EI_CLASS]==ELFCLASS64){Elf64_Ehdr h;lseek(fd,0,SEEK_SET);if(read(fd,&h,sizeof(h))!=(ssize_t)sizeof(h)){close(fd);DIE("Error: Can't read ELF header",98);}for(int i=0;i<EI_NIDENT;i++)h.e_ident[i]=e_ident[i];printf("  Class:                             %s\n",class_str(h.e_ident[EI_CLASS]));printf("  Data:                              %s\n",data_str(h.e_ident[EI_DATA]));printf("  Version:                           %d (current)\n",h.e_ident[EI_VERSION]);printf("  OS/ABI:                            ");printf(osabi_str(h.e_ident[EI_OSABI]),h.e_ident[EI_OSABI]);printf("\n");printf("  ABI Version:                       %d\n",h.e_ident[EI_ABIVERSION]);unsigned int type=h.e_type;unsigned long long entry=h.e_entry;if(h.e_ident[EI_DATA]==ELFDATA2MSB){type=bswap16(type);entry=bswap64(entry);}printf("  Type:                              %s\n",type_str(type));printf("  Entry point address:               0x%lx\n",(unsigned long)entry);}else if(e_ident[EI_CLASS]==ELFCLASS32){Elf32_Ehdr h;lseek(fd,0,SEEK_SET);if(read(fd,&h,sizeof(h))!=(ssize_t)sizeof(h)){close(fd);DIE("Error: Can't read ELF header",98);}for(int i=0;i<EI_NIDENT;i++)h.e_ident[i]=e_ident[i];printf("  Class:                             %s\n",class_str(h.e_ident[EI_CLASS]));printf("  Data:                              %s\n",data_str(h.e_ident[EI_DATA]));printf("  Version:                           %d (current)\n",h.e_ident[EI_VERSION]);printf("  OS/ABI:                            ");printf(osabi_str(h.e_ident[EI_OSABI]),h.e_ident[EI_OSABI]);printf("\n");printf("  ABI Version:                       %d\n",h.e_ident[EI_ABIVERSION]);unsigned int type=h.e_type;unsigned int entry=h.e_entry;if(h.e_ident[EI_DATA]==ELFDATA2MSB){type=bswap16(type);entry=bswap32(entry);}printf("  Type:                              %s\n",type_str(type));printf("  Entry point address:               0x%x\n",entry);}else{close(fd);DIE("Error: Unknown ELF class",98);}close(fd);return 0;}
